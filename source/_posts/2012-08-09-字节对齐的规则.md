---
layout: post
title: "字节对齐的规则"
date: 2012-08-09 16:12
tags: 
  - 从csdn导出
  - C++
categories: 
  - C++
---

在最近的项目中，我们涉及到了“内存对齐”技术。对于大部分程序员来说，“内存对齐”对他们来说都应该是“透明的”。“内存对齐”应该是编译器的“管辖范围”。编译器
为程序中的每个“数据单元”安排在适当的位置上。但是C语言的一个特点就是太灵活，太强大，它允许你干预“内存对齐”。如果你想了解更加底层的秘密，“内存对齐”对你
就不应该再透明了。  
  
一、内存对齐的原因  
大部分的参考资料都是如是说的：  
1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。  
2、性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。  
  
二、对齐规则  
每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma
pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。  
  
规则：  
1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#prag
ma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。  
2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma
pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。  
3、结合1、2颗推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。  
  
三、试验  
我们通过一系列例子的详细说明来证明这个规则吧!  
我试验用的编译器包括GCC 3.4.2和VC6.0的C编译器，平台为Windows XP + Sp2。  
  
我们将用典型的struct对齐来说明。首先我们定义一个struct：  
#pragma pack(n) /* n = 1, 2, 4, 8, 16 */  
struct test_t {  
int a;  
char b;  
short c;  
char d;  
};  
#pragma pack(n)  
首先我们首先确认在试验平台上的各个类型的size，经验证两个编译器的输出均为：  
sizeof(char) = 1  
sizeof(short) = 2  
sizeof(int) = 4  
  
我们的试验过程如下：通过#pragma pack(n)改变“对齐系数”，然后察看sizeof(struct test_t)的值。  
  
1、1字节对齐(#pragma pack(1))  
输出结果：sizeof(struct test_t) = 8 [两个编译器输出一致]  
分析过程：  
1) 成员数据对齐  
#pragma pack(1)  
struct test_t {  
int a;  /* 长度4 < 1 按1对齐；起始offset=0 0%1=0；存放位置区间[0,3] */  
char b;  /* 长度1 = 1 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */  
short c; /* 长度2 > 1 按1对齐；起始offset=5 5%1=0；存放位置区间[5,6] */  
char d;  /* 长度1 = 1 按1对齐；起始offset=7 7%1=0；存放位置区间[7] */  
};  
#pragma pack()  
成员总大小=8  
  
2) 整体对齐  
整体对齐系数 = min((max(int,short,char), 1) = 1  
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 8 /* 8%1=0 */ [注1]  
  
2、2字节对齐(#pragma pack(2))  
输出结果：sizeof(struct test_t) = 10 [两个编译器输出一致]  
分析过程：  
1) 成员数据对齐  
#pragma pack(2)  
struct test_t {  
int a;  /* 长度4 > 2 按2对齐；起始offset=0 0%2=0；存放位置区间[0,3] */  
char b;  /* 长度1 < 2 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */  
short c; /* 长度2 = 2 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */  
char d;  /* 长度1 < 2 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */  
};  
#pragma pack()  
成员总大小=9  
  
2) 整体对齐  
整体对齐系数 = min((max(int,short,char), 2) = 2  
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 10 /* 10%2=0 */  
  
3、4字节对齐(#pragma pack(4))  
输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]  
分析过程：  
1) 成员数据对齐  
#pragma pack(4)  
struct test_t {  
int a;  /* 长度4 = 4 按4对齐；起始offset=0 0%4=0；存放位置区间[0,3] */  
char b;  /* 长度1 < 4 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */  
short c; /* 长度2 < 4 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */  
char d;  /* 长度1 < 4 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */  
};  
#pragma pack()  
成员总大小=9  
  
2) 整体对齐  
整体对齐系数 = min((max(int,short,char), 4) = 4  
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 12 /* 12%4=0 */  
  
4、8字节对齐(#pragma pack（8 ）)  
输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]  
分析过程：  
1) 成员数据对齐  
#pragma pack（8 ）  
struct test_t {  
int a;  /* 长度4 < 8 按4对齐；起始offset=0 0%4=0；存放位置区间[0,3] */  
char b;  /* 长度1 < 8 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */  
short c; /* 长度2 < 8 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */  
char d;  /* 长度1 < 8 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */  
};  
#pragma pack()  
成员总大小=9  
  
2) 整体对齐  
整体对齐系数 = min((max(int,short,char),8 ） = 4  
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 12 /* 12%4=0 */  
  
  
5、16字节对齐(#pragma pack(16))  
输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]  
分析过程：  
1) 成员数据对齐  
#pragma pack(16)  
struct test_t {  
int a;  /* 长度4 < 16 按4对齐；起始offset=0 0%4=0；存放位置区间[0,3] */  
char b;  /* 长度1 < 16 按1对齐；起始offset=4 4%1=0；存放位置区间[4] */  
short c; /* 长度2 < 16 按2对齐；起始offset=6 6%2=0；存放位置区间[6,7] */  
char d;  /* 长度1 < 16 按1对齐；起始offset=8 8%1=0；存放位置区间[8] */  
};  
#pragma pack()  
成员总大小=9  
  
2) 整体对齐  
整体对齐系数 = min((max(int,short,char), 16) = 4  
整体大小(size)=$(成员总大小) 按 $(整体对齐系数) 圆整 = 12 /* 12%4=0 */  
  
四、结论  
8字节和16字节对齐试验证明了“规则”的第3点：“当#pragma
pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果”。另外内存对齐是个很复杂的东西，上面所说的在有些时候也可能不正确。呵呵^_^  

